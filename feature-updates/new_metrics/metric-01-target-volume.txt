Feature Request: Target Volume / Target Share Metric

**WHAT THIS METRIC IS:**
Target Volume tracks how many targets a player receives per game and classifies them into volume tiers (Elite, High, Medium, Low). This metric measures a player's guaranteed involvement in the passing game regardless of catch rate or efficiency.

**WHAT WE'RE TRYING TO ACCOMPLISH:**
- **Identify consistent opportunity**: Players with 8+ targets/game have stable fantasy floors
- **Distinguish workload types**: High-volume players (Tyreek Hill, CeeDee Lamb) vs boom-bust deep threats
- **Predict regression**: Low target volume + high TDs = unsustainable production
- **Support lineup decisions**: In PPR leagues, volume matters more than efficiency
- **Example**: A WR with 10 targets but 4 catches is more valuable long-term than a WR with 4 targets and 4 catches (both had same production, but first has higher opportunity floor)

---

**DATA SOURCE UPDATE (2025-12-22)**: ✅ ESPN API PROVIDES COMPLETE RECEIVING STATS (comprehensive testing completed).

Position Applicability: WR, TE, RB (receiving)
Priority: HIGH
Data Source: ESPN API (current season), Pro Football Reference (historical backfill)
Reference: See `docs/espn/reference/stat_ids.md` for complete stat ID documentation

## 1. Player Data Fetcher Updates

**COMPREHENSIVE ESPN API STAT ID MAPPING (2025-12-22)**:

**All Receiving Stats Verified** (30/146 stat IDs confirmed, 100% core stats coverage):
- `stat_53` = Receptions (Raw) - Primary stat
- `stat_58` = Targets (Raw) - 100% validation across 23+ players
- `stat_42` = Receiving Yards (Raw) - Primary stat
- `stat_43` = Receiving TDs (Raw) - Confirmed
- `stat_60` = Yards Per Reception (Calculated) - Formula: stat_42 / stat_53
- `stat_61` = Receiving Yards (Duplicate of stat_42)
- `stat_41` = Receptions (Duplicate of stat_53)

**Verification Details:**
- Cross-referenced with NFL.com official box scores
- Tested 50+ players across weeks 1, 8, 15, 17 (2024 season)
- Confidence: CONFIRMED (95-100% validation rate)
- See `ESPN_API_PROJECT_SUMMARY.md` for complete methodology

**Example Verification (Nelson Agholor Week 8, 2024):**
```json
{
  "53": 3.0,    // 3 receptions
  "58": 5.0,    // 5 targets
  "42": 36.0,   // 36 yards
  "43": 1.0,    // 1 TD
  "60": 12.0,   // 12.0 YPR (36/3)
  "61": 36.0    // 36 yards (duplicate)
}
```
NFL.com confirmation: Nelson Agholor: 3 catches, 36 yards, 1 TD on 5 targets ✓

Data Sources:
- ESPN API (CURRENT SEASON - Week-by-week data):
  - Stat ID 58 in stats[] array contains targets
  - Available for both actuals (statSourceId=0) and projections (statSourceId=1)
  - Already fetched in existing player-data-fetcher code
  - NO additional API calls needed - data is in existing response!

- Pro Football Reference (HISTORICAL BACKFILL ONLY):
  - URL format: https://www.pro-football-reference.com/players/{letter}/{playerid}/gamelog/{year}/
  - Scraping required for 2021, 2022, 2024 historical simulation data
  - Rate limiting: 1 request per 2 seconds to avoid IP blocking
  - Use ONLY for compile_historical_data.py backfill

New columns to add to players.csv:
- targets (int): Number of times QB threw to player (from stat_58)
- target_share (float): Player targets / team total targets (0.00-1.00)

ESPN API stat ID access:
```python
# In existing ESPN client code
def get_player_targets(player_stats: dict, week: int) -> Optional[int]:
    """Extract targets from stats array using stat_58"""
    for stat_entry in player_stats.get('stats', []):
        if stat_entry.get('scoringPeriodId') == week:
            if stat_entry.get('statSourceId') == 0:  # Actuals
                stats = stat_entry.get('stats', {})
                return int(stats.get('58', 0))  # stat_58 = targets
    return None
```

Implementation approach:
1. Extend existing ESPNClient in player-data-fetcher/espn_client.py
2. Add method to extract stat_58 from existing stats[] array (no new API calls!)
3. Calculate target_share from team totals (aggregate stat_58 by team)
4. For historical data (2021, 2022, 2024): Scrape Pro Football Reference
5. Handle bye weeks: 0 targets (not NULL)
6. Handle injured players: NULL targets vs 0 targets

## 2. Data Manager Updates (league_helper)

PlayerManager updates:
- Add get_player_targets(player_id: int) -> int method
- Add get_player_target_share(player_id: int) -> float method
- Load targets and target_share columns from players.csv
- Validate data: targets >= 0 for pass catchers, 0 for non-pass catchers
- Handle missing data: Default to 0 for QBs/Ks/DST, NULL for games not played

TeamDataManager updates:
- Add get_team_total_targets(team_code: str, week: int) -> int method
- Calculate team-level target totals for target share calculation
- Aggregate player targets by team for validation

Error handling:
- Missing target data: Default to 0 (conservative)
- Invalid target share (>1.0 or <0.0): Log warning, cap at valid range
- Null handling: Distinguish between 0 targets (played but not targeted) vs NULL (didn't play)

## 3. Config File Updates

Add TARGET_VOLUME_SCORING to weekX-X.json files:

{
  "TARGET_VOLUME_SCORING": {
    "THRESHOLDS": {
      "BASE_POSITION": 0,
      "DIRECTION": "INCREASING",
      "STEPS": 2
    },
    "MULTIPLIERS": {
      "VERY_POOR": 0.95,     // <3 targets
      "POOR": 0.975,         // 3-5 targets
      "GOOD": 1.025,         // 6-8 targets
      "EXCELLENT": 1.05      // 8+ targets
    },
    "WEIGHT": 2.0,
    "MIN_WEEKS": 3
  }
}

## 4. Score Player Method Updates

Integration into PlayerManager.score_player():

Step location: Add as new scoring step (Step 11: Target Volume Multiplier)

Formula: STRAIGHT MULTIPLIER (Pattern 1)
score = score * multiplier

Note: multiplier returned from ConfigManager already has WEIGHT exponent applied (multiplier^WEIGHT)

Calculation steps:
1. Load player's targets from players.csv
2. Apply position-specific logic:
   - WR/TE: Weight target volume heavily (critical predictor)
   - RB: Weight target volume for PPR value (receiving backs)
   - QB/K/DST: Skip (targets = 0)

3. Get weighted multiplier and apply to score:
   ```python
   def calculate_target_volume_multiplier(targets: int, position: str) -> Tuple[float, str]:
       # ConfigManager returns multiplier already weighted: base_multiplier ^ WEIGHT
       multiplier, rating = self.config.get_target_volume_multiplier(targets)
       return multiplier, rating

   # Apply to score (multiplier already has WEIGHT applied)
   multiplier, rating = self.calculate_target_volume_multiplier(player.targets, player.position)
   player_score = player_score * multiplier
   reason = f"Target Volume ({rating}): {player.targets} targets"
   ```

Position-specific logic:
- WR: Target volume is PRIMARY predictor (weight = 2.0)
- TE: Similar to WR
- RB: Lower weight unless PPR league (receiving RBs get boost)
- QB/K/DST: Skip entirely (targets = 0)

## 5. Accuracy Simulation Integration

Simulation validation:
1. Add targets and target_share columns to simulation/sim_data/{YEAR}/weeks/week_{NN}/players.csv
2. For week N simulation:
   - Actuals (weeks 1 to N-1): Use actual target data from PFR
   - Projections (weeks N to 17): Use projected targets from ESPN or season-long prorated
3. Schema: targets (int), target_share (float, 0.00-1.00)

Historical data acquisition:
- Scrape Pro Football Reference for 2021, 2022, 2024 seasons
- Extract weekly target data from player game logs
- Calculate target share from team totals
- Timeline: 6-12 hours for all 3 seasons

Validation metrics:
- Measure prediction accuracy before/after target volume integration
- Expected improvement: 15-25% for WR/TE projections
- Track correlation: targets vs actual fantasy points
- Validate target share stability (consistent roles vs volatile)

Special considerations:
- Historical projections: Use ESPN historical data OR prorate season-long projections
- Target quality not captured: 40-yard target = 5-yard screen (limitation)
- Garbage time inflation: Targets in blowouts may skew data
- Late-season games: Target share more predictive than raw targets

### Historical Data Compilation (compile_historical_data.py)

**Purpose:** Backfill historical data for simulation validation

**New columns to add to weekly snapshot CSV files:**
- `targets` (int): Number of times QB threw to player
- `target_share` (float): Player targets / team total targets (0.00-1.00)

**Data source for historical backfill:**
- **Pro Football Reference ONLY** (ESPN API does not provide target data)
  - URL format: https://www.pro-football-reference.com/players/{letter}/{playerid}/gamelog/{year}/
  - Scraping required (no official API)
  - Rate limiting: 1 request per 2 seconds to avoid IP blocking
  - Has explicit "Targets" and "Receptions" columns in game logs
- Alternative for current season: Sleeper API (real-time, unlimited, no auth required)
  - URL: https://api.sleeper.app/v1/stats/nfl/regular/{year}
- Time period: 2021, 2022, 2024 seasons (17 weeks each = 51 weeks total)

**Script updates needed:**

1. **Add data fetcher for target volume:**
   ```python
   def fetch_target_volume_historical_data(year: int, week: int) -> pd.DataFrame:
       """
       Fetch historical target volume data for given year/week.

       Args:
           year: NFL season year (2021, 2022, 2024)
           week: NFL week number (1-17)

       Returns:
           DataFrame with columns: player_id, targets, target_share
       """
       # Scrape PFR game logs for all WR/TE/RB in that week
       # Extract targets column from receiving stats table
       # Calculate team totals and target_share
       # Rate limit: sleep(2) between requests
       pass
   ```

2. **Add column merger:**
   ```python
   def merge_target_volume_data(players_df: pd.DataFrame, targets_df: pd.DataFrame) -> pd.DataFrame:
       """Merge target volume data into weekly snapshot."""
       return players_df.merge(targets_df, on='id', how='left')
   ```

3. **Update main compilation loop:**
   ```python
   # In compile_historical_data.py main loop
   for year in [2021, 2022, 2024]:
       for week in range(1, 18):
           players_df = load_weekly_snapshot(year, week)

           # Add target volume data
           targets_data = fetch_target_volume_historical_data(year, week)
           players_df = merge_target_volume_data(players_df, targets_data)

           save_weekly_snapshot(year, week, players_df)
   ```

**Validation:**
- Verify all 51 weeks (17 weeks × 3 seasons) have complete target data
- Check for missing values: Use NULL for players who didn't play, 0 for players who played but weren't targeted
- Validate data ranges:
  - targets: 0-20 typical for WR/TE (outliers like Kupp may exceed)
  - target_share: 0.0-1.0 (sum of all team WR/TE/RB shares should approach 1.0)
- Cross-check team totals: Sum of player targets should equal team passing attempts
- Validate position filters: Only WR/TE/RB should have targets, QB/K/DST should be 0

**Estimated time:** 6-8 hours for 51 weeks of data across 3 seasons (rate limiting adds ~2-3 hours)

Implementation blockers: None
Dependencies: beautifulsoup4 (PFR scraping) or sleeper-api-wrapper (Sleeper API)
Estimated effort: 2-3 days
