This is the flow I want to see from interacting with the feature-updates folder. We are doing to update guides and create new ones when appropriate to ensure we are following this process.

From now on, I am going to be referring to the txt files in the feature-updates folder as 'epic requests', and the resulting folder when we beginning planning and internal files as the 'epic'
The 'sub-features' are now going to be referred to as just 'features' that are part of the epic

# STAGE 1: FOLLOWING THE FEATURE PLANNING GUIDE
After being asked to help plan based on a file in feature-updates folder, then the agent should begin following the feature_planning_guide
The feature planning guide should begin by creating a folder for the epic and moving the original notes into that folder
Then, a review of the original notes should be done along with a dive into the code
The agent should then propose a list of features that could make up the epic. Each feature should be a dedicated step in the process required to get the entire epic implemented. For small epics, there may only be one feature, but as many features can be made as needed to successfully break the epic down into managable pieces.
The user should be asked to confirm or give their input on how to change the list of features
After confirmation, the agent should create folders for each of the features within the epic folder. Each feature will have its own spec file, checklist file, lessons learned file, and readme
The greater epic folder should contain a readme itself that details what is happening in the epic and maintains a checklist of which features have had 1. their spec file fleshed out from the deep dive, and 2. been completed
The greater epic should also go ahead and be assessed for how to eventually smoke test and QC the epic once all features are completed 

# STAGE 2: FEATURE DEEP DIVES
After the feature folders are created, we're going to loop through each feature and run through the deep-dive guide to flesh out the spec file
We are going to add a step to the deep dive process that involves doing a comparison between the expectations for the current feature and the other ones that have already been fleshed out, and looking for any discrepencies and ensuring everything is aligned in how we are going about the work.
If the discovery from the deep dive uncovers previously unknown scope/work, then the agent should go back to the planning guide and add the new work as a new feature and make a folder for it and update documentation accordingly
We're going to do the deep dive for all features before moving on to anything else. This includes the deep dives into any features discovered during previous deep dives.
Make sure to keep the epic's readme up to date on the progress as it is made

# STAGE 4: SANITY CHECK
After all spec files have been completed, the agent should systematically go through each spec file and compare it to other features 
We are working to ensure all requirements are aligned

# STAGE 5: IMPLEMENTATION
work through each feature and go through the todo creation -> implementation -> post-implementation process
In the post-implementation stage, the agent should go ahead and look through the lessons learned for the specific feature and update the guides accordingly. No need to move the features to a done folder though
If at any point during this process, the user notices an issue with the implementation or missing scope, then the agent should take that info and create a bug fix. A bug fix will go through the same process of having a dedicated folder, deep dive, checklist, todo, etc, except it will be marked as high priority. The agent should stop what it was doing, update documentation so that it can easily pick it up again later, and pivot to working on bringing the bug fix through every stage. 
When creating the bug fix, the agent should
1. Create the folder
2. Create a notes.txt file that outlines the issue and what should be done
3. Ask the user to verify the contents of the notes and add/delete from it how they wish
4. Once the user has finished updating the notes. Update documentation in the epic to reflect the new bug
5. Proceed with the usual use of the guides based on the new notes file 

I also want to add some iterations to the post-implementation work. The agent should pretend it is a Tech Lead reviewing a Pull Request for the changes. The agent should do careful examination looking for:
MERGE/CODE REVIEW CHECKLIST

CORRECTNESS AND LOGIC
- Does the code accomplish what it claims to do?
- Are there logic errors, off-by-one errors, or incorrect conditionals?
- Are edge cases and boundary conditions handled?
- Is null/undefined handling appropriate?

CODE QUALITY AND READABILITY
- Is the code easy to understand without excessive mental overhead?
- Are names (variables, functions, classes) descriptive and consistent?
- Is the code appropriately modular, or are functions/methods doing too much?
- Is there unnecessary complexity that could be simplified?

COMMENTS AND DOCUMENTATION
- Are comments explaining "why" rather than restating "what"?
- Are public APIs and complex logic adequately documented?
- Are there stale or misleading comments?
- Does the PR description explain the change adequately?

REFACTORING CONCERNS
- Does the change introduce duplication that should be abstracted?
- Are there opportunities to improve existing code touched by this change?
- Is the change consistent with existing patterns in the codebase?

TESTING
- Are there sufficient unit/integration tests for new functionality?
- Do tests cover edge cases and failure modes?
- Are existing tests still valid, or do they need updates?

SECURITY
- Input validation and sanitization
- Authentication/authorization checks
- Exposure of sensitive data (logs, errors, responses)
- Injection vulnerabilities (SQL, XSS, command injection)

PERFORMANCE
- Inefficient algorithms or data structures
- Unnecessary database queries or N+1 problems
- Memory leaks or resource cleanup
- Impact on latency-sensitive paths

ERROR HANDLING
- Are errors caught and handled appropriately?
- Are error messages helpful for debugging?
- Is logging sufficient but not excessive?

ARCHITECTURE AND DESIGN
- Does the change fit the overall system architecture?
- Are dependencies flowing in the right direction?
- Is there appropriate separation of concerns?

COMPATIBILITY AND INTEGRATION
- Backwards compatibility with existing clients/APIs
- Database migration safety
- Configuration changes and their rollout
- Dependencies: are new ones justified? Are versions appropriate?

SCOPE AND FOCUS
- Does the PR do one thing well, or is it mixing concerns?
- Are unrelated changes sneaking in?

---
If there are ANY issues with any of the reviews (smoke testing, QC, PR review) then we need to fix the issues then COMPLETELY RESTART THE POST-IMPLEMENTATION STAGE

# STAGE 6: Final QC
After all features have been completed, the agent should go through all of the post-implementation steps (e.g. smoke testing, QC, and PR review) for the epic as a whole. It should ensure that EVERYTHING is working end-to-end based on the original epic request
Bug fixes should be made accordingly to any issues discovered

$ Stage 7: Clean up
Any final commits should be made and the epic should be moved to the done folder