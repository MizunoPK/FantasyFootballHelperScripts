POSITIONAL SCARCITY MULTIPLIER IMPROVEMENT
===========================================

OVERVIEW
--------
Add dynamic positional scarcity analysis to Draft Helper scoring that adjusts recommendations based on the remaining player pool depth at each position. This creates urgency to draft scarce positions (like elite TEs) before they disappear, while deprioritizing deep positions (like WRs with many viable options).

PROBLEM STATEMENT
-----------------
Current DRAFT_ORDER provides static positional bonuses regardless of draft state:
- Round 6 always recommends TE with fixed bonus
- Doesn't adapt if all elite TEs are already gone
- Doesn't recognize when RB pool is depleted but WR pool is deep
- Treats draft pick #30 same as pick #130 for positional value

Example Issue:
- Round 8: Draft helper recommends TE (static DRAFT_ORDER)
- Reality: Top 8 TEs already drafted, only low-tier options remain
- Better strategy: Draft RB/WR where quality options still exist

SOLUTION APPROACH
-----------------
Calculate real-time scarcity score for each position based on:
1. Quality-adjusted remaining players at position (not just count)
2. Roster needs vs availability
3. Positional depth curves (RB/WR deep, TE/QB shallow)
4. Apply dynamic scarcity multiplier to scoring

IMPLEMENTATION DETAILS
----------------------

1. DATA STRUCTURES (NEW CALCULATOR CLASS)
   Location: draft_helper/core/scarcity_calculator.py

   Class: ScarcityCalculator

   Key Concepts:
   - "Value Remaining" = Sum of normalized scores for available players at position
   - "Positional Depth" = How quickly value drops off (steep vs gradual)
   - "Roster Pressure" = How many more players needed at position

2. SCARCITY CALCULATION ALGORITHM

   Method: calculate_scarcity_multiplier(position: str, team_roster: List[FantasyPlayer],
                                         available_players: List[FantasyPlayer]) -> float

   Step 1: Calculate Value Remaining by Position
   ----------------------------------------------
   For each position, sum normalized scores of available players:

   def get_position_value_remaining(position: str, available_players: List[FantasyPlayer]) -> float:
       """
       Calculate total value remaining at a position.
       Uses normalized scores (0-100 scale) for quality-adjusted count.
       """
       position_players = [p for p in available_players if p.position == position]

       # Sum normalized scores (already calculated by normalization_calculator)
       total_value = sum(p.weighted_projection for p in position_players)

       return total_value

   Example at pick #45:
   - RB value remaining: 850 points (20 players * ~42 avg)
   - WR value remaining: 1200 points (30 players * ~40 avg)
   - TE value remaining: 180 points (6 players * ~30 avg)
   - QB value remaining: 400 points (10 players * ~40 avg)

   Step 2: Calculate Positional Depth Curves
   -----------------------------------------
   Different positions have different depth characteristics:

   POSITION_DEPTH_CURVES = {
       'QB': {
           'elite_tier': 6,      # Top 6 QBs significantly better
           'viable_tier': 15,    # QBs 7-15 still startable
           'replacement': 25,    # Replacement level (QB25+)
           'dropoff_rate': 0.85  # Steep dropoff from elite to viable
       },
       'RB': {
           'elite_tier': 12,     # Top 12 RBs (RB1 tier)
           'viable_tier': 30,    # RBs 13-30 (RB2/FLEX tier)
           'replacement': 45,    # Replacement level
           'dropoff_rate': 0.70  # Moderate dropoff (deep position)
       },
       'WR': {
           'elite_tier': 15,     # Top 15 WRs (WR1 tier)
           'viable_tier': 40,    # WRs 16-40 (WR2/FLEX tier)
           'replacement': 60,    # Replacement level
           'dropoff_rate': 0.65  # Gradual dropoff (very deep position)
       },
       'TE': {
           'elite_tier': 3,      # Top 3 TEs (Kelce, Andrews, Kittle tier)
           'viable_tier': 8,     # TEs 4-8 (Still useful)
           'replacement': 15,    # Replacement level
           'dropoff_rate': 0.95  # Extreme dropoff (scarce position)
       },
       'K': {
           'elite_tier': 5,
           'viable_tier': 12,
           'replacement': 20,
           'dropoff_rate': 0.50  # Very flat (kickers all similar)
       },
       'DST': {
           'elite_tier': 5,
           'viable_tier': 12,
           'replacement': 20,
           'dropoff_rate': 0.60  # Relatively flat
       }
   }

   Step 3: Calculate Tier Availability
   -----------------------------------
   Determine how many elite/viable players remain:

   def get_tier_counts(position: str, available_players: List[FantasyPlayer]) -> Dict[str, int]:
       """
       Count how many players remain in each tier for a position.
       Uses pre-draft rankings (ADP or projection-based).
       """
       position_players = [p for p in available_players if p.position == position]

       # Sort by projected points (or ADP if available)
       sorted_players = sorted(position_players, key=lambda p: p.fantasy_points, reverse=True)

       curve = POSITION_DEPTH_CURVES[position]

       tier_counts = {
           'elite': 0,
           'viable': 0,
           'replacement': 0
       }

       for idx, player in enumerate(sorted_players, start=1):
           # Determine overall rank (accounting for already-drafted players)
           overall_rank = idx + count_drafted_at_position(position)

           if overall_rank <= curve['elite_tier']:
               tier_counts['elite'] += 1
           elif overall_rank <= curve['viable_tier']:
               tier_counts['viable'] += 1
           else:
               tier_counts['replacement'] += 1

       return tier_counts

   Step 4: Calculate Roster Pressure
   ---------------------------------
   How urgently do we need more players at this position?

   def get_roster_pressure(position: str, team_roster: List[FantasyPlayer]) -> float:
       """
       Calculate urgency multiplier based on roster needs.

       Returns:
           1.0+ = Need more players at this position
           1.0 = Adequately filled
           0.5-1.0 = Over-filled (have enough)
       """
       from shared_files.configs.draft_helper_config import MAX_POSITIONS

       current_count = sum(1 for p in team_roster if p.position == position)
       max_count = MAX_POSITIONS.get(position, 1)

       # Calculate fill ratio
       fill_ratio = current_count / max_count

       if fill_ratio < 0.5:
           # Critically low (0-1 RBs when need 4)
           return 1.5
       elif fill_ratio < 0.75:
           # Need more (2 RBs when need 4)
           return 1.2
       elif fill_ratio < 1.0:
           # Almost filled (3 RBs when need 4)
           return 1.0
       elif fill_ratio == 1.0:
           # Exactly filled
           return 0.8
       else:
           # Over-filled
           return 0.5

   Step 5: Calculate Scarcity Score
   --------------------------------
   Combine tier availability + dropoff rate + roster pressure:

   def calculate_scarcity_score(position: str, team_roster: List[FantasyPlayer],
                                 available_players: List[FantasyPlayer]) -> float:
       """
       Calculate scarcity score (0-1 scale, higher = more scarce).
       """
       tier_counts = get_tier_counts(position, available_players)
       curve = POSITION_DEPTH_CURVES[position]

       # Elite tier scarcity (0-1 scale)
       elite_remaining_ratio = tier_counts['elite'] / curve['elite_tier']
       elite_scarcity = 1.0 - elite_remaining_ratio  # 0 = all available, 1 = none left

       # Viable tier scarcity
       viable_remaining_ratio = tier_counts['viable'] / (curve['viable_tier'] - curve['elite_tier'])
       viable_scarcity = 1.0 - viable_remaining_ratio

       # Weight elite tier more heavily (elite scarcity matters more)
       tier_scarcity = (elite_scarcity * 0.7) + (viable_scarcity * 0.3)

       # Apply dropoff rate (positions with steep dropoffs have higher scarcity impact)
       position_scarcity = tier_scarcity * curve['dropoff_rate']

       # Factor in roster pressure
       roster_pressure = get_roster_pressure(position, team_roster)

       # Combined scarcity score
       scarcity_score = position_scarcity * roster_pressure

       return scarcity_score

   Step 6: Convert Scarcity Score to Multiplier
   --------------------------------------------
   Map scarcity score (0-1) to multiplier (0.7-1.3):

   def scarcity_score_to_multiplier(scarcity_score: float) -> float:
       """
       Convert scarcity score to multiplier.

       Scarcity Score -> Multiplier:
       0.0 (abundant) -> 0.70x (devalue)
       0.3 (plentiful) -> 0.90x
       0.5 (balanced) -> 1.00x (neutral)
       0.7 (scarce) -> 1.15x
       0.9 (critical) -> 1.30x (highly value)
       1.0 (depleted) -> 1.40x (maximum urgency)
       """
       # Linear mapping with floor/ceiling
       base_multiplier = 0.70 + (scarcity_score * 0.70)  # Maps 0->0.70, 1.0->1.40

       # Apply bounds
       return max(0.70, min(1.40, base_multiplier))

3. INTEGRATION INTO SCORING ENGINE

   Location: draft_helper/core/scoring_engine.py

   UPDATED 7-STEP SCORING (add scarcity after DRAFT_ORDER):

   def score_player(self, p, enhanced_scorer=None, team_data_loader=None,
                    positional_ranking_calculator=None, scarcity_calculator=None):
       """
       Calculate score for Add to Roster Mode (8-step calculation).

       New Scoring System:
       1. Get normalized seasonal fantasy points (0-N scale)
       2. Apply ADP multiplier
       3. Apply Player Ranking multiplier
       4. Apply Team ranking multiplier
       5. Add DRAFT_ORDER bonus (round-based position priority)
       6. Apply POSITIONAL SCARCITY multiplier (NEW)
       7. Subtract Bye Week penalty
       8. Subtract Injury penalty
       """
       # STEPS 1-5: Existing scoring through DRAFT_ORDER bonus
       ...
       draft_bonus_score = enhanced_score + draft_bonus

       # STEP 6: Apply POSITIONAL SCARCITY multiplier (NEW)
       if scarcity_calculator:
           available_players = [pl for pl in self.players if pl.drafted == 0 and pl.locked == 0]
           scarcity_multiplier = scarcity_calculator.calculate_scarcity_multiplier(
               p.position,
               self.team.roster,
               available_players
           )
           scarcity_score = draft_bonus_score * scarcity_multiplier
           self.logger.debug(
               f"Step 6 - After scarcity for {p.name}: {scarcity_score:.2f} "
               f"({scarcity_multiplier:.2f}x multiplier)"
           )
       else:
           scarcity_score = draft_bonus_score

       # STEP 7: Bye penalty
       bye_penalty = self.compute_bye_penalty_for_player(p)
       bye_adjusted_score = scarcity_score - bye_penalty

       # STEP 8: Injury penalty
       injury_penalty = self.compute_injury_penalty(p)
       final_score = bye_adjusted_score - injury_penalty

       return final_score

4. EXAMPLE SCENARIOS

   Scenario A: Early Draft (Pick #15, Round 2)
   -------------------------------------------
   RB Analysis:
   - Elite RBs remaining: 10/12 (83% available)
   - Viable RBs remaining: 18/18 (100% available)
   - Tier scarcity: (0.17 * 0.7) + (0.0 * 0.3) = 0.119
   - Position scarcity: 0.119 * 0.70 (dropoff rate) = 0.083
   - Roster pressure: 1.5 (have 1 RB, need 4)
   - Scarcity score: 0.083 * 1.5 = 0.125
   - Multiplier: 0.70 + (0.125 * 0.70) = 0.79x

   TE Analysis:
   - Elite TEs remaining: 2/3 (67% available)
   - Viable TEs remaining: 5/5 (100% available)
   - Tier scarcity: (0.33 * 0.7) + (0.0 * 0.3) = 0.231
   - Position scarcity: 0.231 * 0.95 (dropoff rate) = 0.219
   - Roster pressure: 1.5 (have 0 TE, need 2)
   - Scarcity score: 0.219 * 1.5 = 0.329
   - Multiplier: 0.70 + (0.329 * 0.70) = 0.93x

   Result: RB and TE both plentiful, slight devalue from baseline

   Scenario B: Mid Draft (Pick #75, Round 8)
   -----------------------------------------
   RB Analysis:
   - Elite RBs remaining: 1/12 (8% available)
   - Viable RBs remaining: 8/18 (44% available)
   - Tier scarcity: (0.92 * 0.7) + (0.56 * 0.3) = 0.812
   - Position scarcity: 0.812 * 0.70 = 0.568
   - Roster pressure: 1.0 (have 3 RBs, need 4)
   - Scarcity score: 0.568 * 1.0 = 0.568
   - Multiplier: 0.70 + (0.568 * 0.70) = 1.10x

   TE Analysis:
   - Elite TEs remaining: 0/3 (0% available)
   - Viable TEs remaining: 2/5 (40% available)
   - Tier scarcity: (1.0 * 0.7) + (0.60 * 0.3) = 0.880
   - Position scarcity: 0.880 * 0.95 = 0.836
   - Roster pressure: 1.5 (have 0 TE, need 2)
   - Scarcity score: 0.836 * 1.5 = 1.254 (capped at 1.0)
   - Multiplier: 0.70 + (1.0 * 0.70) = 1.40x (MAXIMUM URGENCY)

   Result: TE critically scarce, RB moderately scarce
   Even a mediocre TE gets huge boost, must draft TE NOW

   Scenario C: Late Draft (Pick #125, Round 13)
   --------------------------------------------
   RB Analysis:
   - Elite RBs remaining: 0/12 (0% available)
   - Viable RBs remaining: 2/18 (11% available)
   - Tier scarcity: (1.0 * 0.7) + (0.89 * 0.3) = 0.967
   - Position scarcity: 0.967 * 0.70 = 0.677
   - Roster pressure: 0.5 (have 4 RBs, maxed out)
   - Scarcity score: 0.677 * 0.5 = 0.339
   - Multiplier: 0.70 + (0.339 * 0.70) = 0.94x

   WR Analysis:
   - Elite WRs remaining: 0/15 (0% available)
   - Viable WRs remaining: 12/25 (48% available)
   - Tier scarcity: (1.0 * 0.7) + (0.52 * 0.3) = 0.856
   - Position scarcity: 0.856 * 0.65 = 0.556
   - Roster pressure: 0.8 (have 4 WRs, almost maxed)
   - Scarcity score: 0.556 * 0.8 = 0.445
   - Multiplier: 0.70 + (0.445 * 0.70) = 1.01x

   K Analysis:
   - Elite Ks remaining: 5/5 (100% available)
   - Dropoff rate: 0.50 (flat, kickers similar)
   - Roster pressure: 1.5 (have 0 K, need 1)
   - Scarcity score: ~0.0 (abundant)
   - Multiplier: 0.70x (devalue, don't draft yet)

   Result: RB/WR both depleted but roster full, slight devalue
   K abundant, strong devalue (wait until last picks)

5. CONFIGURATION

   Location: shared_files/configs/draft_helper_config.py

   # Enable/disable scarcity scoring
   ENABLE_SCARCITY_SCORING = True

   # Scarcity multiplier bounds
   SCARCITY_MULTIPLIER_MIN = 0.70  # Maximum devalue for abundant positions
   SCARCITY_MULTIPLIER_MAX = 1.40  # Maximum boost for scarce positions

   # Scarcity weight (tune impact strength)
   SCARCITY_WEIGHT = 1.0  # 1.0 = full impact, 0.5 = half impact, 1.5 = stronger

   # Position depth curves (as defined above)
   POSITION_DEPTH_CURVES = { ... }

   # Scarcity calculation method
   SCARCITY_METHOD = 'tier_based'  # 'tier_based' or 'value_based' or 'hybrid'

6. TRADE/WAIVER MODE CONSIDERATIONS

   For Trade/Waiver analysis:
   - Scarcity should be LESS impactful (roster already established)
   - Reduce scarcity weight: SCARCITY_WEIGHT_TRADE = 0.5
   - Focus on player quality over positional urgency
   - Still useful for identifying waiver wire gems (scarce position + quality player)

7. INTERACTION WITH DRAFT_ORDER

   Key Question: Does scarcity replace or complement DRAFT_ORDER?

   Recommendation: COMPLEMENT (not replace)
   - DRAFT_ORDER: Strategic framework (when to draft positions)
   - Scarcity: Tactical adaptation (adjust for actual draft state)

   Example:
   - DRAFT_ORDER says "draft TE in round 6" (+50 bonus)
   - Scarcity says "all elite TEs gone" (1.40x multiplier)
   - Combined effect: Strong signal to grab best remaining TE NOW

   Alternative Approach:
   - Replace DRAFT_ORDER entirely with scarcity
   - Purely reactive system (no pre-planned strategy)
   - Risk: Less structure, could miss positional windows

8. TESTING REQUIREMENTS

   Unit Tests (draft_helper/tests/test_scarcity_calculator.py):
   - Test tier counting with various draft states
   - Test roster pressure calculation
   - Test scarcity score calculation
   - Test multiplier conversion
   - Test edge cases (all players drafted at position, etc.)

   Integration Tests:
   - Test scarcity integration in scoring engine
   - Verify multiplier increases as position depletes
   - Test early vs mid vs late draft scenarios
   - Verify interaction with DRAFT_ORDER bonus

   Simulation Tests:
   - Run drafts with scarcity enabled vs disabled
   - Measure roster balance (does scarcity prevent position runs?)
   - Measure win rates (does scarcity improve outcomes?)
   - Test different SCARCITY_WEIGHT values

9. SIMULATION INTEGRATION

   Add to simulation parameters:

   JSON Parameter Files (draft_helper/simulation/parameters/*.json):
   {
       ...existing parameters...,

       "SCARCITY_MULTIPLIER_MIN": [0.70, 0.80],
       "SCARCITY_MULTIPLIER_MAX": [1.30, 1.40],
       "SCARCITY_WEIGHT": [0.75, 1.0, 1.25],

       "TE_ELITE_TIER": [3, 4],
       "TE_DROPOFF_RATE": [0.90, 0.95],
       "RB_ELITE_TIER": [10, 12],
       "RB_DROPOFF_RATE": [0.65, 0.75]
   }

   Test optimal scarcity settings across hundreds of drafts.

10. ADVANCED FEATURES (FUTURE)

    A. League-Aware Scarcity
       - Track what OTHER teams need (not just your team)
       - Predict position runs (if 3 teams need TE, draft TE before run starts)
       - Game theory: "draft player before rival needs him"

    B. Bye Week Scarcity
       - Factor in bye week distribution
       - Increase scarcity if remaining players all have same bye week
       - Helps avoid bye week conflicts

    C. Handcuff Scarcity
       - If you draft Saquon Barkley, increase scarcity of his backup
       - Recognize backup RB value tied to starter ownership

    D. Streaming Strategy
       - Reduce scarcity for streaming positions (K, DST)
       - Recognize weekly waiver availability

    E. Auction Draft Scarcity
       - Translate scarcity to budget allocation
       - Spend more on scarce positions when available

BENEFITS
--------
1. Adaptive draft strategy (responds to actual draft flow)
2. Prevents "missing out" on scarce positions (TE, elite RBs)
3. Avoids reaching for positions with deep depth (WRs)
4. Better roster balance across positions
5. Competitive advantage vs static draft strategies
6. Mathematically rigorous (not just intuition)

POTENTIAL DOWNSIDES
-------------------
1. Could create "panic drafting" (overreact to scarcity)
2. Complex calculation (performance impact)
3. Requires accurate tier definitions (what is "elite"?)
4. May conflict with value-based drafting (take best player available)
5. Could over-weight scarcity vs player quality

CONFIGURATION TUNING
--------------------
Start conservative:
- SCARCITY_WEIGHT = 0.75 (moderate impact)
- SCARCITY_MULTIPLIER_MIN = 0.80 (gentle devalue)
- SCARCITY_MULTIPLIER_MAX = 1.25 (gentle boost)

Run simulations and gradually increase if positive results.

Monitor for:
- Drafting low-quality players just because position is scarce
- Missing elite players at abundant positions (passing on elite WR for mediocre TE)
- Position imbalances (too many of one position)

COMPARISON TO DRAFT_ORDER
--------------------------
DRAFT_ORDER (Current):
+ Simple, predictable
+ Based on expert consensus
+ Provides strategic structure
- Static, doesn't adapt
- Ignores actual draft state
- Same for pick #1 and pick #100

Scarcity (New):
+ Dynamic, adapts to draft
+ Reflects actual availability
+ Prevents position runs
+ Data-driven
- More complex
- Requires tuning
- Could overreact to noise

Recommendation: USE BOTH
- DRAFT_ORDER: Base strategy
- Scarcity: Tactical adjustment
- Combined: Strategic + Adaptive

IMPLEMENTATION CHECKLIST
------------------------
[ ] Create draft_helper/core/scarcity_calculator.py
[ ] Define POSITION_DEPTH_CURVES in config
[ ] Implement tier counting logic
[ ] Implement roster pressure calculation
[ ] Implement scarcity score algorithm
[ ] Update scoring_engine.py to integrate scarcity
[ ] Write unit tests for ScarcityCalculator
[ ] Write integration tests for scoring engine
[ ] Add scarcity parameters to simulation config
[ ] Run baseline simulations (scarcity on vs off)
[ ] Compare results and tune parameters
[ ] Update CLAUDE.md documentation

ESTIMATED EFFORT
----------------
Development: 5-6 hours
Testing: 3 hours
Simulation/Tuning: 2-3 hours
Total: 10-12 hours

PRIORITY: HIGH
This improvement provides significant strategic value and uses only existing data. Directly addresses a key weakness in static DRAFT_ORDER system.

IMPLEMENTATION NOTES
--------------------
1. Start with simple tier-based scarcity (as described)
2. Test thoroughly in simulations
3. Consider phased rollout:
   - Phase 1: Only apply to TE (most obvious scarcity position)
   - Phase 2: Expand to RB/WR
   - Phase 3: Full implementation across all positions
4. Monitor for unintended consequences (over-drafting scarce but low-quality players)
5. May want to cap scarcity bonus (don't let bad TE score higher than elite WR)
